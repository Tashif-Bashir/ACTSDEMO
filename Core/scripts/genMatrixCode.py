#!/usr/bin/env python3

import textwrap

multiplications = [
    ((2, 2), (2, 2)),
    ((1, 2), (2, 1)),
    ((8, 1), (1, 8)),
    ((6, 8), (8, 8)),
    ((8, 8), (8, 8)),
    ((8, 8), (8, 6)),
    ((6, 8), (8, 6)),
    ((6, 6), (6, 6)),
]


def render_matrix(shape):
    return f"ActsMatrix<{shape[0]}, {shape[1]}>"


def render_assert(identifier):
    return f'static_assert(!{identifier}.IsRowMajor, "Matrix storage order must be ColumMajor");'


def cnvIdx(i, j, dim):
    return j * dim[0] + i


def multiply(dimA, dimB):
    assert dimA[1] == dimB[0]
    dimC = dimA[0], dimB[1]
    body = ""
    for i in range(dimC[0]):
        for j in range(dimC[1]):
            ex = f"pC[{cnvIdx(i, j, dimC)}] = "
            for k in range(dimA[1]):
                if k > 0:
                    ex += " + "
                ex += f"pA[{cnvIdx(i, k, dimA)}] * pB[{cnvIdx(k, j, dimB)}]"
            body += ex + ";\n"
    return body.strip()


def transpose(dim):
    body = ""
    for i in range(dim[0]):
        for j in range(dim[1]):
            body += f"pB[{cnvIdx(i, j, dim)}] = pA[{cnvIdx(j, i, dim)}];\n"
    return body.strip()


header = "// This function is AUTOGENERATED. Do not edit! //"
line = "/" * len(header)
header = line + "\n" + header + "\n" + line

for a, b in multiplications:
    body = multiply(a, b)

    body = (
        render_assert("A")
        + "\n"
        + render_assert("B")
        + "\n"
        + f"{render_matrix((a[0], b[1]))} C;double* pC = C.data();\n"
        + "const double* pA = A.data();\n"
        + "const double* pB = B.data();"
        + "\n\n"
        + body
        + "\n\nreturn C;"
    )

    signature = f"inline {render_matrix((a[0], b[1]))} multiply(const {render_matrix(a)}& A, const {render_matrix(b)}& B)"
    body = "\n".join(
        [
            header,
            signature + " {",
            textwrap.indent(body, prefix=" " * 2),
            "}",
        ]
    )

    print(body)
    print()

body = transpose((6, 6))
body = (
    render_assert("A")
    + "\n"
    + f"{render_matrix((6, 6))} B;\n"
    + "double* pB = B.data();\n"
    + "const double* pA = A.data();\n"
    + body
    + "\n\nreturn B;"
)
signature = (
    f"inline {render_matrix((6, 6))} transpose(const {render_matrix((6, 6))}& A)"
)
body = "\n".join(
    [
        header,
        signature + " {",
        textwrap.indent(body, prefix=" " * 2),
        "}",
    ]
)
print(body)
