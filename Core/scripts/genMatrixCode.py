#!/usr/bin/env python3

import sympy as sp
from sympy.utilities.codegen import codegen
import textwrap

multiplications = [
    ((2, 2), (2, 2)),
    ((1, 2), (2, 1)),
    ((8, 1), (1, 8)),
    ((6, 8), (8, 8)),
    ((8, 8), (8, 8)),
    ((8, 8), (8, 6)),
    ((6, 8), (8, 6)),
    ((6, 6), (6, 6)),
]


def render_matrix(shape):
    return f"ActsMatrix<{shape[0]}, {shape[1]}>"


def render_assert(identifier):
    return f'static_assert(!{identifier}.IsRowMajor, "Matrix storage order must be ColumMajor");'


def extract_body(expression):
    raw = codegen(("D", expression), language="C")[0][1]
    raw = raw.replace("D_result", "pOut")
    raw = "\n".join(raw.split("\n")[13:-4])
    body = textwrap.dedent(raw)
    return body


#  def multiply(dimA, dimB):
#  assert dimA[1] == dimB[0]
#  dimC = dimA[0], dimB[1]
#  body = ""
#  for i in range(dimC[0]):
#  for j in range(dimC[1]):
#  ex = f"C({i}, {j}) = "
#  for k in range(dimA[1]):
#  if k > 0:
#  ex += " + "
#  ex += f"A({i}, {k}) * B({k}, {j})"
#  ex += ";"
#  body += ex + "\n"
#  return body.strip()


def cnvIdx(i, j, dim):
    return j * dim[0] + i


def multiply(dimA, dimB):
    assert dimA[1] == dimB[0]
    dimC = dimA[0], dimB[1]
    body = ""
    for i in range(dimC[0]):
        for j in range(dimC[1]):
            #             ex = f"C({i}, {j}) = "
            ex = f"pC[{cnvIdx(i, j, dimC)}] = "
            for k in range(dimA[1]):
                if k > 0:
                    ex += " + "
                #                 ex += f"A({i}, {k}) * B({k}, {j})"
                ex += f"pA[{cnvIdx(i, k, dimA)}] * pB[{cnvIdx(k, j, dimB)}]"
            body += ex + ";\n"
    return body.strip()


def transpose(dim):
    body = ""
    for i in range(dim[0]):
        for j in range(dim[1]):
            #  body += f"B({i}, {j}) = A({j}, {i});\n"
            body += f"pB[{cnvIdx(i, j, dim)}] = pA[{cnvIdx(j, i, dim)}];\n"
    return body.strip()


header = "// This function is AUTOGENERATED. Do not edit! //"
line = "/" * len(header)
header = line + "\n" + header + "\n" + line

for a, b in multiplications:
    #  A = sp.MatrixSymbol("pA", *a)
    #  B = sp.MatrixSymbol("pB", *b)

    #  if A.shape == (2, 2):
    #  C = (A.T * B.T).T
    #  else:
    #  C = A * B

    #  body = extract_body(C)
    body = multiply(a, b)

    body = (
        render_assert("A")
        + "\n"
        + render_assert("B")
        + "\n"
        + f"{render_matrix((a[0], b[1]))} C;double* pC = C.data();\n"
        + "const double* pA = A.data();\n"
        + "const double* pB = B.data();"
        + "\n\n"
        + body
        + "\n\nreturn C;"
    )

    signature = f"inline {render_matrix((a[0], b[1]))} multiply(const {render_matrix(a)}& A, const {render_matrix(b)}& B)"
    body = "\n".join(
        [
            header,
            signature + " {",
            textwrap.indent(body, prefix=" " * 2),
            "}",
        ]
    )

    print(body)
    print()

body = transpose((6, 6))
body = (
    render_assert("A")
    + "\n"
    + f"{render_matrix((6, 6))} B;\n"
    + "double* pB = B.data();\n"
    + "const double* pA = A.data();\n"
    + body
    + "\n\nreturn B;"
)
signature = (
    f"inline {render_matrix((6, 6))} transpose(const {render_matrix((6, 6))}& A)"
)
body = "\n".join(
    [
        header,
        signature + " {",
        textwrap.indent(body, prefix=" " * 2),
        "}",
    ]
)
print(body)
